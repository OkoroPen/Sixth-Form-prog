Code
Ôòö
Okoro, Pentecost 209-DCO-25 (Student)
‚ÄãOkoro, Pentecost 209-DCO-25 (Student)‚Äã
window.cellSize = 40;
window.boardSize = 15;
window.boardPath = [];
window.homePaths = {};

let started = false;
let paused = false;
let canvas;
let game;
let playerName = localStorage.getItem("playerName") || "Player 1";
let playerColor = localStorage.getItem("playerColor") || "red";


function setup() {
  const container = document.getElementById("canvas-container");
  canvas = createCanvas(window.boardSize * window.cellSize, window.boardSize * window.cellSize);
  canvas.parent(container);

  buildBoardPath();
  buildHomePaths();

  game = new Game({ onUpdate: updateUI });
  initializePlayers();


  document.getElementById("start-btn")?.addEventListener("click", () => {
    if (!started) {
      started = true;
      loop();
      game.startGame();
    }
  });

  document.getElementById("roll-dice-btn")?.addEventListener("click", () => {
    if (!started) { started = true; loop(); game.startGame(); return; }
    if (!paused && game.getCurrentPlayer().isHuman) game.rollDice();
  });

  document.getElementById("pause-btn")?.addEventListener("click", () => {
    paused = !paused;
    if (paused) noLoop();
    else loop();
  });

  document.getElementById("restart-btn")?.addEventListener("click", restartGame);

  document.getElementById("settings-btn")?.addEventListener("click", () => {
    document.getElementById("settings-menu").classList.remove("hidden");
    noLoop();
  });

  document.getElementById("save-settings")?.addEventListener("click", () => {
    document.getElementById("settings-menu").classList.add("hidden");
    loop();
  });

  noLoop(); // Game starts paused
}


function updateUI(dice) {
  const dr = document.getElementById("dice-result");
  if (dr) dr.innerText = `üé≤ Dice: ${dice[0]}, ${dice[1]}`;
  const cur = game.getCurrentPlayer();
  const td = document.getElementById("turn-display");
  if (td) td.innerText = `Turn: ${cur ? cur.name : "Waiting..."}`;
}


function initializePlayers() {
  game.players = [];
  const colors = ["red", "green", "yellow", "blue"];
  const names = ["Red Bot", "Green Bot", "Yellow Bot", "Blue Bot"];
  colors.forEach((color, i) => {
    const isHuman = (color === playerColor);
    const name = isHuman ? playerName : names[i];
    const p = new Player(i, name, color, isHuman);
    p.tokens.forEach(t => t.resetToBase());
    game.addPlayer(p);
  });
}


function draw() {
  background(255);
  drawBoard();
  drawTokens();
  drawDice(game.dice[0], game.dice[1]);

  if (paused) {
    fill(0, 0, 0, 150);
    rect(0, 0, width, height);
    fill(255);
    textSize(28);
    textAlign(CENTER, CENTER);
    text("Paused", width / 2, height / 2);
  }
}



function drawBoard() {
  const cs = window.cellSize;
  const bs = window.boardSize;

  // Draw base grid background (no thick borders)
  noStroke();
  fill(255);
  for (let i = 0; i < bs; i++) {
    for (let j = 0; j < bs; j++) {
      rect(i * cs, j * cs, cs, cs);
    }
  }

  // Quadrants (home zones)
  fill("red"); rect(0, 0, 6 * cs, 6 * cs);
  fill("green"); rect(9 * cs, 0, 6 * cs, 6 * cs);
  fill("blue"); rect(0, 9 * cs, 6 * cs, 6 * cs);
  fill("yellow"); rect(9 * cs, 9 * cs, 6 * cs, 6 * cs);

  // Token homes
  drawTokenHoles(3 * cs, 3 * cs, "red");
  drawTokenHoles(12 * cs, 3 * cs, "green");
  drawTokenHoles(3 * cs, 12 * cs, "blue");
  drawTokenHoles(12 * cs, 12 * cs, "yellow");

  // Outline board path (exclude home zone areas)
  stroke(120);
  strokeWeight(1);
  for (const tile of window.boardPath) {
    const gridX = tile.x / cs;
    const gridY = tile.y / cs;
    const inRedHome = (gridX < 6 && gridY < 6);
    const inGreenHome = (gridX >= 9 && gridY < 6);
    const inBlueHome = (gridX < 6 && gridY >= 9);
    const inYellowHome = (gridX >= 9 && gridY >= 9);
    if (!inRedHome && !inGreenHome && !inBlueHome && !inYellowHome) {
      noFill();
      rect(tile.x, tile.y, cs, cs);
    }
  }

  drawSafeZones();
  drawCenterFinish();
  drawEntrySquares();
}


function drawTokenHoles(cx, cy, color) {
  push();
  stroke(color);
  strokeWeight(3);
  fill(255);
  const holeSize = window.cellSize * 0.1;
  const offset = window.cellSize * 0.5;
  ellipse(cx - offset, cy - offset, holeSize);
  ellipse(cx + offset, cy - offset, holeSize);
  ellipse(cx - offset, cy + offset, holeSize);
  ellipse(cx + offset, cy + offset, holeSize);
  pop();
}


function drawSafeZones() {
  const cs = window.cellSize;
  noStroke();

  // Red path
  fill("red");
  for (let i = 1; i <= 6; i++) rect(i * cs, 7 * cs, cs, cs);

  // Green path
  fill("green");
  for (let j = 1; j <= 6; j++) rect(7 * cs, j * cs, cs, cs);

  // Yellow path
  fill("yellow");
  for (let i = 13; i >= 8; i--) rect(i * cs, 7 * cs, cs, cs);

  // Blue path
  fill("blue");
  for (let j = 13; j >= 8; j--) rect(7 * cs, j * cs, cs, cs);
}

function drawCenterFinish() {
  const cs = window.cellSize;
  const left = 6 * cs, top = 6 * cs, right = 9 * cs, bottom = 9 * cs;
  const cx = (left + right) / 2, cy = (top + bottom) / 2;
  push();
  noStroke();
  fill("green"); triangle(left, top, right, top, cx, cy);
  fill("yellow"); triangle(right, top, right, bottom, cx, cy);
  fill("blue"); triangle(left, bottom, right, bottom, cx, cy);
  fill("red"); triangle(left, top, left, bottom, cx, cy);
  fill(255);
  rectMode(CENTER);
  rect(cx, cy, cs * 0.6, cs * 0.6, 6);
  pop();
}


function drawTokens() {
  if (!game || !game.players) return;
  game.players.forEach(p => {
    p.tokens.forEach(t => {
      t.updateCoordinates();
      t.draw();
    });
  });
}


function mousePressed() {
  if (!started || paused) return;
  const player = game.getCurrentPlayer();
  if (!player.isHuman) return;
  const sel = player.selectToken(mouseX, mouseY, game.validMoves);
  if (sel) {
    const token = player.tokens[sel.tokenId];
    game.moveToken(player, token, sel.steps, sel.source);
  }
}


function buildBoardPath() {
  const cs = window.cellSize;
  const p = [];

  // Red side - bottom row going right, then up column 6
  for (let i = 0; i <= 5; i++) p.push({ x: i * cs, y: 6 * cs });
  for (let j = 5; j >= 0; j--) p.push({ x: 6 * cs, y: j * cs });

  // Green side - top row going right, then down column 8
  for (let i = 7; i <= 8; i++) p.push({ x: i * cs, y: 0 });
  for (let j = 1; j <= 5; j++) p.push({ x: 8 * cs, y: j * cs });
  for (let i = 9; i <= 14; i++) p.push({ x: i * cs, y: 6 * cs });

  // Yellow side - right column going down, then left row 8
  for (let j = 7; j <= 8; j++) p.push({ x: 14 * cs, y: j * cs });
  for (let i = 13; i >= 9; i--) p.push({ x: i * cs, y: 8 * cs });
  for (let j = 9; j <= 14; j++) p.push({ x: 8 * cs, y: j * cs });

  // Blue side - bottom row going left, then up column 6
  for (let i = 7; i >= 6; i--) p.push({ x: i * cs, y: 14 * cs });
  for (let j = 13; j >= 9; j--) p.push({ x: 6 * cs, y: j * cs });
  for (let i = 5; i >= 0; i--) p.push({ x: i * cs, y: 8 * cs });

  // Connect back to start - up to row 7 on column 0
  p.push({ x: 0, y: 7 * cs });

  window.boardPath = p.slice(0, 52);
}

function buildHomePaths() {
  const cs = window.cellSize;
  window.homePaths = {
    red: [ {x:1,y:7},{x:2,y:7},{x:3,y:7},{x:4,y:7},{x:5,y:7},{x:6,y:7} ],
    green: [ {x:7,y:1},{x:7,y:2},{x:7,y:3},{x:7,y:4},{x:7,y:5},{x:7,y:6} ],
    yellow: [ {x:13,y:7},{x:12,y:7},{x:11,y:7},{x:10,y:7},{x:9,y:7},{x:8,y:7} ],
    blue: [ {x:7,y:13},{x:7,y:12},{x:7,y:11},{x:7,y:10},{x:7,y:9},{x:7,y:8} ]
  };
}


function drawEntrySquares() {
  const cs = window.cellSize;
  const entries = [
    { color: 'red', x: 1 * cs, y: 6 * cs },
    { color: 'green', x: 8 * cs, y: 1 * cs },
    { color: 'yellow', x: 13 * cs, y: 8 * cs },
    { color: 'blue', x: 6 * cs, y: 13 * cs }
  ];
  push();
  strokeWeight(3);
  entries.forEach(e => {
    stroke(e.color);
    noFill();
    rect(e.x, e.y, cs, cs);
  });
  pop();
}

function drawDice(die1, die2) {
  const cs = window.cellSize;
  const diceSize = cs * 1.2;
  const startX = 6.5 * cs - diceSize - 5;
  const startY = 6.5 * cs - diceSize / 2;

  drawSingleDie(startX, startY, diceSize, die1);
  drawSingleDie(startX + diceSize + 10, startY, diceSize, die2);
}

function drawSingleDie(x, y, size, value) {
  push();
  fill(255);
  stroke(50);
  strokeWeight(2);
  rect(x, y, size, size, 6);

  fill(30);
  noStroke();
  const dotSize = size * 0.15;
  const cx = x + size / 2;
  const cy = y + size / 2;
  const offset = size * 0.25;

  if (value === 1) {
    ellipse(cx, cy, dotSize);
  } else if (value === 2) {
    ellipse(cx - offset, cy - offset, dotSize);
    ellipse(cx + offset, cy + offset, dotSize);
  } else if (value === 3) {
    ellipse(cx - offset, cy - offset, dotSize);
    ellipse(cx, cy, dotSize);
    ellipse(cx + offset, cy + offset, dotSize);
  } else if (value === 4) {
    ellipse(cx - offset, cy - offset, dotSize);
    ellipse(cx + offset, cy - offset, dotSize);
    ellipse(cx - offset, cy + offset, dotSize);
    ellipse(cx + offset, cy + offset, dotSize);
  } else if (value === 5) {
    ellipse(cx - offset, cy - offset, dotSize);
    ellipse(cx + offset, cy - offset, dotSize);
    ellipse(cx, cy, dotSize);
    ellipse(cx - offset, cy + offset, dotSize);
    ellipse(cx + offset, cy + offset, dotSize);
  } else if (value === 6) {
    ellipse(cx - offset, cy - offset, dotSize);
    ellipse(cx + offset, cy - offset, dotSize);
    ellipse(cx - offset, cy, dotSize);
    ellipse(cx + offset, cy, dotSize);
    ellipse(cx - offset, cy + offset, dotSize);
    ellipse(cx + offset, cy + offset, dotSize);
  }
  pop();
}

function restartGame() {
  started = false;
  paused = false;
  game = new Game({ onUpdate: updateUI });
  initializePlayers();

  const dr = document.getElementById("dice-result");
  if (dr) dr.innerText = "Dice: -";
  const td = document.getElementById("turn-display");
  if (td) td.innerText = "Turn: Waiting...";
  noLoop();
}

class Token {
  constructor(id, player) {
    this.id = id;
    this.player = player;
    this.color = player.color;
    this.state = 'base';      
    this.pathIndex = -1;      
    this.homeIndex = -1;
    this.distanceTraveled = 0;
    this.x = 0; this.y = 0;
    this.targetX = 0; this.targetY = 0;
    this.speed = 8;          
    this.flashUntil = 0;
    this.updateCoordinates(true);
  }

  resetToBase() {
    this.state = 'base';
    this.pathIndex = -1;
    this.homeIndex = -1;
    this.distanceTraveled = 0;
    this.updateCoordinates(true);
  }

  activate() {
    this.state = 'active';
    this.pathIndex = this.player.startIndex;
    this.distanceTraveled = 0;
    this.updateCoordinates(true);
  }

  canEnterHome() {
    return this.distanceTraveled >= window.boardPath.length - 1;
  }

  stepForward(steps) {
    if (this.state !== 'active') return false;

    const boardLen = window.boardPath.length;
    const entryIndex = this.player.homeEntry;
   
    this.distanceTraveled += steps;

    if (this.canEnterHome()) {
      let distToEntry = (entryIndex - this.pathIndex + boardLen) % boardLen;
     
      if (distToEntry === 0 || steps > distToEntry) {
        const stepsIntoHome = (distToEntry === 0) ? steps - 1 : steps - distToEntry - 1;
        if (stepsIntoHome >= 0 && stepsIntoHome < window.homePaths[this.player.color].length) {
          this.state = 'homePath';
          this.homeIndex = stepsIntoHome;
          this.updateCoordinates();
          return true;
        } else {
          this.distanceTraveled -= steps;
          return false;
        }
      }
    }

    this.pathIndex = (this.pathIndex + steps) % boardLen;
    this.updateCoordinates();
    return true;
  }

  moveHomePath(steps) {
    if (this.state !== 'homePath') return false;

    this.homeIndex += steps;
    if (this.homeIndex >= window.homePaths[this.player.color].length) {
      this.homeIndex = window.homePaths[this.player.color].length - 1;
      this.state = 'finished';
    }

    this.updateCoordinates();
    return true;
  }

  updateCoordinates(force = false) {
    let tx, ty;
    if (this.state === 'base') {
      const base = this.player.baseCoords[this.id];
      tx = base.x; ty = base.y;
    } else if (this.state === 'active') {
      const tile = window.boardPath[this.pathIndex];
      tx = tile.x + window.cellSize / 2;
      ty = tile.y + window.cellSize / 2;
    } else if (this.state === 'homePath') {
      const h = window.homePaths[this.player.color][this.homeIndex];
      tx = h.x * window.cellSize + window.cellSize / 2;
      ty = h.y * window.cellSize + window.cellSize / 2;
    } else if (this.state === 'finished') {
      tx = 7.5 * window.cellSize;
      ty = 7.5 * window.cellSize;
    }

    if (force) { this.x = tx; this.y = ty; }

    this.targetX = tx;
    this.targetY = ty;
  }

  animate() {
    this.x += (this.targetX - this.x) * 0.2;
    this.y += (this.targetY - this.y) * 0.2;
  }

  draw() {
    this.animate();
    push();
    stroke(0);
    if (this.flashUntil && frameCount < this.flashUntil) fill(255, 200, 0);
    else fill(this.color);
    ellipse(this.x, this.y, window.cellSize * 0.78);
    noStroke();
    fill(0);
    textSize(12);
    textAlign(CENTER, CENTER);
    text(this.id + 1, this.x, this.y + 1);
    pop();
  }

  flash() { this.flashUntil = frameCount + 18; }
}


class Player {
  constructor(index, name, color, isHuman = false) {
    this.index = index;
    this.name = name;
    this.color = color;
    this.isHuman = isHuman;
    this.tokens = [];
    this.captureCount = 0;
    this.startIndex = this.getStartIndex();
    this.homeEntry = this.getHomeEntry();
    this.baseCoords = this.generateBaseCoords();
    for (let i = 0; i < 4; i++) this.tokens.push(new Token(i, this));
  }

  getStartIndex() {
    const map = { red: 1, green: 14, yellow: 27, blue: 40 };
    return map[this.color];
  }

  getHomeEntry() {
    const map = { red: 50, green: 12, yellow: 25, blue: 38 };
    return map[this.color];
  }

  generateBaseCoords() {
    const cs = window.cellSize;
    let cx = 0, cy = 0;
    switch (this.color) {
      case "red": cx = 3 * cs; cy = 3 * cs; break;
      case "green": cx = 12 * cs; cy = 3 * cs; break;
      case "blue": cx = 3 * cs; cy = 12 * cs; break;
      case "yellow": cx = 12 * cs; cy = 12 * cs; break;
    }
    const offset = cs * 0.9;
    return [
      { x: cx - offset / 2, y: cy - offset / 2 },
      { x: cx + offset / 2, y: cy - offset / 2 },
      { x: cx - offset / 2, y: cy + offset / 2 },
      { x: cx + offset / 2, y: cy + offset / 2 }
    ];
  }

  generateMoves(dice, diceUsed) {
    const moves = [];
    for (const t of this.tokens) {
      for (let d = 0; d < dice.length; d++) {
        if (diceUsed[d]) continue;
        const steps = dice[d];
        if (t.state === 'base' && steps === 6) {
          moves.push({ token: t, steps: 0, source: d });
        } else if (t.state === 'active') {
          const boardLen = window.boardPath.length;
          const entryIndex = this.homeEntry;
         
          if (t.canEnterHome()) {
            let distToEntry = (entryIndex - t.pathIndex + boardLen) % boardLen;
           
            if (distToEntry === 0) {
              const stepsIntoHome = steps - 1;
              if (stepsIntoHome >= 0 && stepsIntoHome < window.homePaths[this.color].length) {
                moves.push({ token: t, steps, source: d });
              }
            } else if (steps <= distToEntry) {
              moves.push({ token: t, steps, source: d });
            } else {
              const stepsIntoHome = steps - distToEntry - 1;
              if (stepsIntoHome < window.homePaths[this.color].length) {
                moves.push({ token: t, steps, source: d });
              }
            }
          } else {
            moves.push({ token: t, steps, source: d });
          }
        } else if (t.state === 'homePath') {
          const homeLen = window.homePaths[this.color].length;
          if (t.homeIndex + steps <= homeLen) moves.push({ token: t, steps, source: d });
        }
      }
    }
    return moves;
  }

  selectToken(mx, my, validMoves) {
    for (const mv of validMoves) {
      const t = mv.token;
      const d = dist(mx, my, t.x, t.y);
      if (d < window.cellSize * 0.6) return { tokenId: t.id, steps: mv.steps, source: mv.source };
    }
    return null;
  }

  isWinner() {
    return this.tokens.every(t => t.state === 'finished');
  }
}

<html>
<head>
  <title>Ludo GO</title>
  <link rel="stylesheet" href="homepage.css">
</head>
<body>
  <div class="container">
    <h1>üé≤ Ludo GO </h1>
    <label for="playerName">Enter Your Name:</label><br>
    <input type="text" id="playerName" placeholder= required><br>
    <label for="playerColor">Choose Your Color:</label><br>
    <select id="playerColor">
      <option value="red">üî¥ Red</option>
      <option value="green">üíö Green</option>
      <option value="blue">üîµ Blue</option>
      <option value="yellow">üíõ Yellow</option>
     
    </select><br>
    <button id="startBtn">Start Game</button>
  </div>

  <script>
    document.getElementById("startBtn").addEventListener("click", function() {
      const name = document.getElementById("playerName").value.trim();
      const color = document.getElementById("playerColor").value;

      if (!name) {
        alert("Please enter your name before starting!");
        return;
      }
      localStorage.setItem("playerName", name);
      localStorage.setItem("playerColor", color);
      window.location.href = "game.html";
    });
  </script>
</body>
</html>
body {
    font-family: Arial, sans-serif;
    background: aquamarine;
    color: white;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
}

.container {
    background-color: rgb(58, 37, 37);
    padding: 30px;
    border-radius: 12px;
    text-align: center;
    width: 320px;
}
h1 {
    margin-bottom: 15px;
}

input, select, button {
    width: 80%;
    padding: 10px;
    margin: 10px 0;
    border: none;
    border-radius: 6px;
    font-size: 16px;
}

input {
    text-align: center;
}

select {
    cursor: pointer;
}

button {
    background-color: lightseagreen;
    color: white;
    font-weight: bold;
    cursor: pointer;
    transition: 0.3s;
}

button:hover {
    background-color: lightseagreen;
}

class Game {
  constructor({ onUpdate = null } = {}) {
    this.players = [];
    this.onUpdate = onUpdate;
    this.dice = [0, 0];
    this.diceUsed = [true, true];
    this.validMoves = [];
    this.currentPlayerIndex = 0;
    this.safeZones = [];
    this.winners = [];
    this.aiDelay = 700;
    this.awaitingHumanMove = false;
    this.victoryMode = 'both';
  }

  addPlayer(p) { this.players.push(p); }

  setSafeZones(arr) { this.safeZones = arr; }

  getCurrentPlayer() { return this.players[this.currentPlayerIndex]; }

  startGame() {
    if (this.players.length !== 4) return;
    this.setSafeZones(this.players.map(p => p.startIndex));

    // Randomize who starts
    let rolls = [];
    for (let i = 0; i < this.players.length; i++) {
      const total = Math.floor(Math.random() * 6) + 1;
      rolls.push({ index: i, total });
    }
    rolls.sort((a, b) => b.total - a.total);
    this.currentPlayerIndex = rolls[0].index;

    const starter = this.players[this.currentPlayerIndex];
    const logEl = document.getElementById('log');
    if (logEl) logEl.innerText = `${starter.name} starts first!`;

    this.rollDice();
    this.handleAITurnIfNeeded();
  }

  rollDice() {
    this.dice = [1 + Math.floor(Math.random() * 6), 1 + Math.floor(Math.random() * 6)];
    playSound("dice-sound");
    this.diceUsed = [false, false];
    const cur = this.getCurrentPlayer();

    if (cur.isHuman) {
      this.awaitingHumanMove = true;
      this.updateValidMoves();
      if (this.onUpdate) this.onUpdate(this.dice);
      const logEl = document.getElementById('log');
      if (logEl) logEl.innerText = `${cur.name}, choose a token to move! Dice: ${this.dice[0]}, ${this.dice[1]}`;
      return;
    }

    this.updateValidMoves();
    if (this.onUpdate) this.onUpdate(this.dice);
    this.handleAITurnIfNeeded();
  }

  updateValidMoves() {
    const p = this.getCurrentPlayer();
    if (!p) return;
    this.validMoves = p.generateMoves(this.dice, this.diceUsed);
  }

  moveToken(player, token, steps, source) {
    if (this.diceUsed[source]) return false;

    if (token.state === 'base' && steps === 0) {
      token.activate();
    } else if (token.state === 'active') {
      token.stepForward(steps);
    } else if (token.state === 'homePath') {
      token.moveHomePath(steps);
      if (token.state === 'finished') {
        this.checkVictoryByHome(player);
      }
    }

    if (token.state === 'active') this.checkCollisions(player, token);

    this.diceUsed[source] = true;
    this.updateValidMoves();

    if (this.diceUsed.some(u => !u) && this.validMoves.length > 0) {
      if (player.isHuman) {
        const logEl = document.getElementById('log');
        if (logEl) logEl.innerText = `${player.name}, use your other dice!`;
      } else {
        const aiPlayer = player;
        setTimeout(() => this.handleAISecondMove(aiPlayer), this.aiDelay);
      }
      return true;
    }

    this.awaitingHumanMove = false;
    this.nextPlayer();

    if (!this.getCurrentPlayer().isHuman) {
      this.handleAITurnIfNeeded();
    }

    return true;
  }

  handleAISecondMove(aiPlayer) {
    if (this.getCurrentPlayer() !== aiPlayer) return;
   
    this.updateValidMoves();
    const moves = this.validMoves;
    if (!moves || moves.length === 0) {
      this.nextPlayer();
      this.handleAITurnIfNeeded();
      return;
    }

    let chosen = moves.find(m => this.wouldCapture(aiPlayer, m)) ||
                 moves.find(m => m.token.state === 'base') ||
                 moves.reduce((a, b) => (a.steps >= b.steps ? a : b), moves[0]);

    this.moveToken(aiPlayer, chosen.token, chosen.steps, chosen.source);
  }

  checkCollisions(player, token) {
    if (this.safeZones.includes(token.pathIndex)) return;

    for (const other of this.players) {
      if (other === player) continue;
      for (const opp of other.tokens) {
        if (opp.state === 'active' && opp.pathIndex === token.pathIndex) {
          opp.resetToBase();
          opp.flash();
          player.captureCount = (player.captureCount || 0) + 1;
          playSound("capture-sound");

          const logEl = document.getElementById('log');
          if (logEl)
            logEl.innerText = `${player.name} captured ${other.name}'s token!`;

          this.checkVictoryByCapture(player);
          return;
        }
      }
    }
  }

  checkVictoryByCapture(player) {
    if (this.victoryMode === 'home') return false;
    if (player.captureCount >= 4) {
      this.winners.push(player);
      setTimeout(() => {
        alert(`${player.name} wins by capturing all opponents! üèÜ`);
        restartGame();
      }, 150);
      return true;
    }
    return false;
  }

  checkVictoryByHome(player) {
    if (this.victoryMode === 'capture') return false;
    if (player.tokens.every(t => t.state === 'finished')) {
      this.winners.push(player);
      setTimeout(() => {
        alert(`${player.name} wins by getting all tokens home! üèÜ`);
        restartGame();
      }, 150);
      return true;
    }
    return false;
  }

  nextPlayer() {
    let attempts = 0;
    do {
      this.currentPlayerIndex = (this.currentPlayerIndex + 1) % this.players.length;
      attempts++;
      if (attempts > 10) break;
    } while (this.players[this.currentPlayerIndex].isWinner());

    this.dice = [0, 0];
    this.diceUsed = [true, true];
    this.validMoves = [];
    if (this.onUpdate) this.onUpdate(this.dice);
   
    const cur = this.getCurrentPlayer();
    if (cur && cur.isHuman) {
      const logEl = document.getElementById('log');
      if (logEl) logEl.innerText = `${cur.name}'s turn! Click "Roll Dice" to roll.`;
    }
  }

  handleAITurnIfNeeded() {
    const cur = this.getCurrentPlayer();
    if (!cur || cur.isHuman) return;

    setTimeout(() => {
      if (this.dice[0] === 0) this.rollDice();

      setTimeout(() => {
        this.updateValidMoves();
        const moves = this.validMoves;
        if (!moves || moves.length === 0) {
          this.nextPlayer();
          this.handleAITurnIfNeeded();
          return;
        }

        // Choose smart AI move
        let chosen = moves.find(m => this.wouldCapture(cur, m)) ||
                     moves.find(m => m.token.state === 'base') ||
                     moves.reduce((a, b) => (a.steps >= b.steps ? a : b), moves[0]);

        this.moveToken(cur, chosen.token, chosen.steps, chosen.source);
      }, this.aiDelay);
    }, this.aiDelay / 2);
  }

  wouldCapture(player, move) {
    const pos = (move.token.pathIndex + move.steps) % window.boardPath.length;
    for (const other of this.players) {
      if (other === player) continue;
      for (const ot of other.tokens) {
        if (ot.state === 'active' && ot.pathIndex === pos && !this.safeZones.includes(pos))
          return true;
      }
    }
    return false;
  }
}

function playSound(id) {
  const audio = document.getElementById(id);
  if (audio) {
    audio.currentTime = 0;
    audio.play();
  }
}

<html>
<head>
  <title>Ludo GO</title>
  <link rel="stylesheet" href="game.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
</head>

<body>
  <header>
    <h1>üé≤ Ludo GO</h1>
  </header>

  <main id="game-container">
    <div id="canvas-container"></div>

    <div id="controls">
      <div id="info">
        <div id="turn-display">Turn: Waiting...</div>
        <div id="dice-result">Dice: -</div>
      </div>

      <div id="buttons">
        <button id="start-btn">Start Game ‚ñ∂Ô∏è</button>
        <button id="roll-dice-btn">Roll Dice üé≤</button>
        <button id="pause-btn">Pause ‚è∏Ô∏è</button>
        <button id="restart-btn">Restart ‚ôªÔ∏è</button>
        <button id="settings-btn">Settings ‚öôÔ∏è</button>
      </div>
    </div>
  </main>

  <div id="settings-menu" class="hidden">
    <div id="settings-content">
      <h2>Game Settings and Rules</h2>
      <label><input type="checkbox" id="toggle-sound" checked> Enable Sound</label>
      <label><input type="checkbox" id="toggle-timer" checked> Enable Timer</label>
      <p>Click "Save to return to the game"</p>
      <!--p><strong>RULES</strong></p-->
      <p>
        Start the game by pressing either <strong>Start Game ‚ñ∂Ô∏è</strong> or <strong>Roll Dice üé≤</strong>.<br>
        Roll the dice by pressing <strong>Roll Dice üé≤</strong>.<br>
        Wait for your turn.<br>
        Tap on your colored token (1, 2, 3, or 4) to move.<br>
        Capture opponent tokens by landing on them.<br>
        Pause with <strong>Pause ‚è∏Ô∏è</strong> or restart anytime with <strong>Restart ‚ôªÔ∏è</strong>.<br>
        Have fun and aim to get all four tokens to the center first!
      </p>
      <button id="save-settings">Close</button>
    </div>
  </div>

  <audio id="dice-sound" src="diceroll.mp3"></audio>
  <audio id="token-moves" src="game.html"></audio>
  <audio id="capture-sound" src="capture.mp3"></audio>

  <script src="player.js"></script>
  <script src="token.js"></script>
  <script src="game.js"></script>
  <script src="sketch.js"></script>
</body>
</html>

body {
  margin: 0;
  font-family: "Arial", sans-serif;
  background: linear-gradient(120deg, aliceblue, lightsteelblue);
  color: black;
  overflow: hidden;
}

header {
  background-color: black;
  color: white;
  padding: 1em 0;
  text-align: center;
}

#game-container {
  display: flex;
  gap: 20px;
  justify-content: center;
  align-items: start;
  padding: 16px;
}

#canvas-container {
  flex: 0 0 auto;
  width: 600px;
  height: 600px;
  display: flex;
  justify-content: center;
  align-items: center;
  border: 3px solid black;
  background: white;
}

#controls {
  display: flex;
  flex-direction: column;
  gap: 12px;
  min-width: 220px;
}

#info {
  text-align: left;
}

#buttons {
  display: flex;
  flex-direction: column;
}

button {
  background-color: rgb(40, 40, 209);
  color: rgb(210, 207, 228);
  border: none;
  padding: 10px 18px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 1em;
}

button:hover {
  background-color: rgb(65, 65, 240);
}

.hidden {
  display: none;
}

#settings-menu {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
}

#settings-content {
  background: black;
  color: white;
  padding: 24px 30px;
  border-radius: 12px;
  width: 400px;
  text-align: left;
  box-shadow: 0 4px 12px rgba(255, 255, 255, 0.2);
  border: 2px solid royalblue;
}

#settings-content h2 {
  text-align: center;
  margin-top: 0;
  color: royalblue;
}

#settings-content p {
  font-size: 14px;
  line-height: 1.4;
  margin-bottom: 10px;
  color: white;
}

#save-settings {
  display: block;
  margin: 20px auto 0;
  padding: 8px 16px;
  background-color: royalblue;
  color: white;
  border: none;
  font-weight: bold;
  border-radius: 6px;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

#save-settings:hover {
  background-color: dodgerblue;
}
#settings-menu {
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease, visibility 0.3s ease;
}

#settings-menu:not(.hidden) {
  opacity: 1;
  visibility: visible;
}



